---
layout: post
title: 安卓四大组件之Service
tags:
- Android
categories: Android四大组件
---
#Android Service
##1. 进程
- 四大组件都是运行在主线程   
  Android中的服务 也是在后台运行  可以理解成是在后台运行并且是没有界面的Activity  
-进程的生命周期：  
  + Foreground process 前台进程  用户正在交互  可以理解成相 当于 Activity执行onResume方法  
  + Visible process 可视进程 用户没有在交互 但用户还一直能看得见页面    相当于Activity执行     了onPause方法   
  + Service Process  服务进程  通过startService()开启了一个服务  
  + Background process  后台进程  当前用户看不见页面 相当于Activity执行了onStop方法  
  + Empty process 空进程
- 进程的生命周期：
  + 应用程序一启动的时候就创建了进程；  
  + 当应用程序退出的时候进程并没有退出；  
  + 只有手工停止这个进程，进程才会结束；  
  + 操作系统尽量长时间的运行应用程序的进程，为了保证内从空间不被大量占用，它会按照进程的优先级，从低到高一级一级的杀死进程，直到内存空间被清理的差不多。

##2.服务
- 什么是服务？  
 + windows下的服务：没有界面、长期运行在后台的应用程序；
 + android下的服务：应用程序的一个组件，没有界面activity，长期运行在后台；  
 + 进程：是应用程序运行的载体。
 + 进程与应用程序之间的关系： linux操作系统创建一个进程，这个进程负责运行dalvik虚拟机,Android的应用程序都是运行在dalvik虚拟机上的。
- start方式开启服务  
  + 特点   
        1. 服务被创建时调用onCreate、onStartCommand；  
	   	2. 服务只能被创建一次，可以开启多次onStartCommand；  
	   	3. 服务只能被停止一次；   
		4. 没有onPause、onStop、onResume、onRestart方法，因为service没有界面，长期运行在后台。
		5. startservice 方式开启服务 服务就会在后台长期运行 直到用户手工停止 或者调用StopService方法 服务才会被销毁
		6. 服务被开启后 会在设置页面里面的 running里面找得到这个服务
  +  生命周期的方法
  		1. onCreate:服务被创建的时候调用这个方法；
		2. onStartCommand ：开启服务
	    3. onDestroy：销毁服务  
- 使用服务注册特殊的广播接收者
 + 创建我们要注册的广播接收者  
	public class ScreenReceiver extends BroadcastReceiver {  
		String action = intent.getAction();  
		if ("android.intent.action.SCREEN_OFF".equals(action)) {  
			System.out.println("说明屏幕锁屏了");  
		}else if("android.intent.action.SCREEN_ON".equals(action)){ 
			System.out.println("说明屏幕解锁了");  
				}  
			}  
		}
 + 创建一个服务 用来注册广播接收者  
 	//在这个方法里面注册广播接收者
	 public void onCreate() {  
		//[1]获取ScreenReceiver实例  
        receiver = new ScreenReceiver();  
        //[2]创建IntentFilter对象  
		IntentFilter filter = new IntentFilter();  
		//[3]添加注册的事件  
		filter.addAction("android.intent.action.SCREEN_OFF");  
		filter.addAction("android.intent.action.SCREEN_ON");  
		//[4]通过代码的方式注册  
		registerReceiver(receiver, filter);  
		super.onCreate();  
	}  
	//当服务销毁的时候调用  
	@Override  
	public void onDestroy() {  
		//当actvivity销毁的时候  取消注册广播接收者   
		unregisterReceiver(receiver);  
		super.onDestroy();  
	} 









 + 一定要配置  
    <service android:name="com.itheima.registerbroadcast.ScreenService"></service>
##3 bindService
    bindService绑定服务、unBindService解除绑定的服务；
	服务是在被绑定的时候被创建，调用oncreate、onbind方法；
    服务只能被绑定一次；
	服务只能被解除一次，接触绑定的时候调用onUnbind、onDestrory方法，如果多次解除绑定会抛出异常；
    

    推荐的方式：

    startService：开启并创建一个服务，服务长期运行在后台；
    bindService:绑定服务，可以调用服务里面的方法；
    unBindService：解除服务，停止服务里面的方法；
    stopService：停止服务，销毁服务对象；

- 为什么要引入bindservice的API   
  	为了调用服务中的业务逻辑方法。
-   混合方式开启服务 
  1. 先调用startService()方法 保证服务在后台长期运行
  2. 调用bindservice()目的获取我们定义的中间人对象 调用服务里面的方法
  3. unbindservice() 看这时候服务会不会销毁
  4. 最后调用stopservice() 停止服务 
##4  绑定服务抽取接口
    接口（interface）： 对外开放暴露的功能，但是不会暴露功能实现的细节；
    让中间人实现服务接口的目的：只对外暴露接口里面业务逻辑方法，隐藏中间人里面的其他方法；

 	步骤：

    1、创建一个服务的接口类，里面包含需要对外暴露的业务逻辑方法：
		public interface IService {
		public void callMethodInService();
	}
    
    2、让服务中的中间人实现了服务的接口类：
		private class MyBinder extends Binder implements IService{
		
		//(实现服务接口中的方法)使用中间人调用服务里的方法
		public void callMethodInService(){
			methodInService();
		   }
		}

	3、在activity中声明接口的成员变量：
		private IService myBinder;

    4、强制转换成服务的接口类型
		private class MyConn implements ServiceConnection {

		/**
		 * 服务连接成功时调用这个方法
		 */
		@Override
		public void onServiceConnected(ComponentName name, IBinder service) {
			//强制转换成服务的接口类型
			myBinder = (IService) service;
		}

     5、在activity中通过接口的成员变量调用服务的业务逻辑方法：
		public void call(View view){
		myBinder.callMethodInService();

	}

##5 绑定服务的应用场景
	
     应用场景：

     1、需要在后台运行一定的业务逻辑，而且需要与服务器端交互数据，都是写在服务里面的。
     2、天气预报、股票行情软件；
##6 远程服务 AIDL
    (1)远程服务 运行在其他应用里面的服务   写在别的应用程序的工程里的服务，使用别的应用程序的进程运行这个服务（安装在同一个手机上的应用程序
    (2)本地服务 运行在自己应用里面的服务  写在自己的应用程序的工程里的服务 ，使用自己应用程序的进程运行这个服务；
    (3)进行进程间通信  IPC  Inter Process Communication（进程间的通讯）
    (4)aidl Android interface Defination Language Android接口定义语言 专门是用来解决进程间通信的   
    （5）aidl的接口类里面不需要public 、protected、private 等修饰符，默认是公开共享；
-  aidl 实现步骤和之前调用服务里面的方法的区别 
  + 先把Iservice.java文件变成aidl文件
  + adil 不认识public 把public 给我去掉
  + 会自动生成一个Stub类 实现ipc 
  + 我们定义的中间人对象 直接继承stub
  + 想要保证2个应用程序的aidl文件是同一个 要求aidl文件所在包名相同
  + 获取中间人对象Stub.asinterface(Ibinder obj)